<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poseidon2 on TON</title>
    <style>
        body {
            background-color: #000000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        h1 {
            font-family: 'VT323', monospace;
            text-align: center;
            font-size: 3em;
            text-shadow: 0 0 10px #00ff0091;
        }
        pre {
            background-color: #0a0a0a;
            border: 1px solid #00ff00;
            padding: 20px;
            overflow-x: auto;
        }
        code {
            color: #0dbd0d;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
</head>
<body>
    <h1>Poseidon2 on TON</h1>
    <pre><code>
</body>
</html>
;; ===========================================================
;; Poseidon2 Hash Function Implementation in FunC for TON
;; ===========================================================
;; Author: Cryptskii
;; Date: 2024-09-16
;; Description:
;; This smart contract implements the Poseidon2 cryptographic 
;; hash function optimized for the TON blockchain.
;; It includes multi-limb arithmetic to handle 256-bit 
;; integers, modular operations, and the Poseidon sponge 
;; construction.
;; ===========================================================
#include "./imports/stdlib.fc";
;; ===========================================================
;; 1. Constants and Parameters
;; ===========================================================

;; Poseidon2 constants
const int P0 = 0x43E1F593F0000001;
const int T = 3;
const int D = 5;
const int RF = 8;
const int RP = 57;
const int TOTAL_ROUNDS = RF + RP;
const int MAX_ALLOWED_INPUTS = 100;

;; Round constants for Poseidon2 permutation
;; Ensure all RC_*_* constants from RC_0_0 to RC_64_2 are defined here
;; Example:

;; Poseidon2 constants
const int P0 = 0x43E1F593F0000001;
const int T = 3;
const int D = 5;
const int RF = 8;
const int RP = 57;
const int TOTAL_ROUNDS = RF + RP;
const int MAX_ALLOWED_INPUTS = 100;

;; Round constants for Poseidon2 permutation
const int RC_0_0 = 0x2a0876c5c9916d05;
const int RC_0_1 = 0xac04e27fa7463c83;
const int RC_0_2 = 0x83feb5746829b362;
const int RC_1_0 = 0x6796291ef355bc93;
const int RC_1_1 = 0x5b1f3e7bcb0b9286;
const int RC_1_2 = 0xa17a4aaa0adc3c95;
const int RC_2_0 = 0x0c9d3af52a477399;
const int RC_2_1 = 0x0c1adaf617d79258;
const int RC_2_2 = 0x27f0c330098af53e;
const int RC_3_0 = 0x6de35ec3d3ceac6a;
const int RC_3_1 = 0xe52781eac1ba9ed4;
const int RC_3_2 = 0xe3cca15e36384782;
const int RC_4_0 = 0x16f0abb8bcb29639;
const int RC_4_1 = 0x900c378b2a846ba9;
const int RC_4_2 = 0x9f98b58f602f4662;
const int RC_5_0 = 0x4bda0bdd19ae2de7;
const int RC_5_1 = 0x4f3476297ef15ee5;
const int RC_5_2 = 0x62f911df2ed6d7ab;
const int RC_6_0 = 0x554a29553a599daa;
const int RC_6_1 = 0x66feaba55bc84e9c;
const int RC_6_2 = 0x9a2e8a4493983f47;
const int RC_7_0 = 0x076782892166b8a1;
const int RC_7_1 = 0x34345ac5ab1529fe;
const int RC_7_2 = 0xa1115629ef2ec427;
const int RC_8_0 = 0x82063421e2e7bcdf;
const int RC_8_1 = 0xcef106dff53ed543;
const int RC_8_2 = 0xef340a260ba8d2df;
const int RC_9_0 = 0x6f6f4b0b1f6be4ad;
const int RC_9_1 = 0x9194a3287bffa1e3;
const int RC_9_2 = 0xcc98f9bb68758270;
const int RC_10_0 = 0x79c38c910e4ab3f7;
const int RC_10_1 = 0x883b81b0e4bb36aa;
const int RC_10_2 = 0xe2d4be39aef4f9e0;
const int RC_11_0 = 0xde47b871b6ce0885;
const int RC_11_1 = 0x8665701221bba42c;
const int RC_11_2 = 0x50bd62fab9f1dedf;
const int RC_12_0 = 0x134936906cd97688;
const int RC_12_1 = 0x29ead19954f75956;
const int RC_12_2 = 0x17e459e304598052;
const int RC_13_0 = 0xf5319839d59e9d44;
const int RC_13_1 = 0x2415c7804932fff3;
const int RC_13_2 = 0xf8850410e775752a;
const int RC_14_0 = 0xa46ee94e9fd654ad;
const int RC_14_1 = 0x87b30bc37aa5e4fb;
const int RC_14_2 = 0x55f71fc88481202a;
const int RC_15_0 = 0xcdbbe18b703f967f;
const int RC_15_1 = 0xc8def6954d137bf6;
const int RC_15_2 = 0x2ecfc4188f34c5f6;
const int RC_16_0 = 0x4deed244face7ac4;
const int RC_16_1 = 0x3de72e8dba4d2c8a;
const int RC_16_2 = 0xc7e8f413ab8235dc;
const int RC_17_0 = 0xc8cb976a5694d6cf;
const int RC_17_1 = 0x47fe460aa33b6c3c;
const int RC_17_2 = 0xde197a5ecb3d5eab;
const int RC_18_0 = 0x2c9822ef23036da1;
const int RC_18_1 = 0xb1e9fa9e137dd0f4;
const int RC_18_2 = 0x80e418bd36fa9d46;
const int RC_19_0 = 0xaaaec6334c9b6bfa;
const int RC_19_1 = 0x6345d999d84d777a;
const int RC_19_2 = 0xb0fa71ea7bb5581f;
const int RC_20_0 = 0x4ba890014fadb4c9;
const int RC_20_1 = 0xebe69c65cd47705f;
const int RC_20_2 = 0xd90deafab420effa;
const int RC_21_0 = 0xaa721b808de1be39;
const int RC_21_1 = 0xeb93fef041e2b46d;
const int RC_21_2 = 0x6dbe9a8bd6e7f902;
const int RC_22_0 = 0xc7f6f0384b3b7f78;
const int RC_22_1 = 0x18268e884cf92f68;
const int RC_22_2 = 0x53015ac6ba6d3ed1;
const int RC_23_0 = 0xa064abeb139c0e71;
const int RC_23_1 = 0x2434e25bb2a974ed;
const int RC_23_2 = 0xf7713b63d39169f5;
const int RC_24_0 = 0x12d6ef531ea62731;
const int RC_24_1 = 0xe2b7db61cbd75925;
const int RC_24_2 = 0xc02156165fa3240e;
const int RC_25_0 = 0xc75c1807b8fa8e45;
const int RC_25_1 = 0x8abfa19b310c2be6;
const int RC_25_2 = 0x579a207a1cf63f8b;
const int RC_26_0 = 0x7100af474c9a8235;
const int RC_26_1 = 0x08678e54dd69406a;
const int RC_26_2 = 0xb9cb87b5c6558606;
const int RC_27_0 = 0x877957454204e905;
const int RC_27_1 = 0xc1f85e8c5b5c78a7;
const int RC_27_2 = 0xde51bd12b51232ab;
const int RC_28_0 = 0x1df3f9a2077c10b9;
const int RC_28_1 = 0xd9586cfb9c10d341;
const int RC_28_2 = 0xb68a67d30c1dd6e0;
const int RC_29_0 = 0x39539fe71a78547a;
const int RC_29_1 = 0x7d4282213674d646;
const int RC_29_2 = 0x6927236962a1b3f9;
const int RC_30_0 = 0x5c39eb3b82481c1d;
const int RC_30_1 = 0x3b37d4b20fcd21a8;
const int RC_30_2 = 0x552617f6b3b9bfda;
const int RC_31_0 = 0x75032507af8f1b0c;
const int RC_31_1 = 0xb70fa651d4fd7d3c;
const int RC_31_2 = 0x532476553be3e4fa;
const int RC_32_0 = 0x97c58678cfe08744;
const int RC_32_1 = 0x5d610ffba83cca60;
const int RC_32_2 = 0x09cfd55d2797c187;
const int RC_33_0 = 0xfb3c639a87b44e71;
const int RC_33_1 = 0x164877417944e162;
const int RC_33_2 = 0x2f5cb26cbe3da149;
const int RC_34_0 = 0x5c4ccb1cde376374;
const int RC_34_1 = 0x61a92fec8fe31c7e;
const int RC_34_2 = 0x6ef5c5dac27573c1;
const int RC_35_0 = 0x79842206806f7e13;
const int RC_35_1 = 0x9d40d016a58e509c;
const int RC_35_2 = 0x204f5c954807294e;
const int RC_36_0 = 0x378dbe0e50005a96;
const int RC_36_1 = 0x84e6a29338c34cc0;
const int RC_36_2 = 0x5e87b2c7a375b33f;
const int RC_37_0 = 0x88414aab9853df08;
const int RC_37_1 = 0x77de824a4b743580;
const int RC_37_2 = 0xb0f2d68a011f0008;
const int RC_38_0 = 0x9c98740e8e8e59dc;
const int RC_38_1 = 0x72815db757ce3eed;
const int RC_38_2 = 0x1e280b21d676abd0;
const int RC_39_0 = 0xf663469b48d1691d;
const int RC_39_1 = 0x9b0548fe0410f3f9;
const int RC_39_2 = 0x8231d224b386e210;
const int RC_40_0 = 0xed7a503add3a2689;
const int RC_40_1 = 0x4bb06d666b692dc5;
const int RC_40_2 = 0x2d0c4f7819968b7c;
const int RC_41_0 = 0x0e0706991ccc01cf;
const int RC_41_1 = 0x9454401715556e4c;
const int RC_41_2 = 0x8a442b2cb9c00d73;
const int RC_42_0 = 0x3e7f2433e049c65e;
const int RC_42_1 = 0xd8f627d0ef452079;
const int RC_42_2 = 0x5d9296c31c0e7820;
const int RC_43_0 = 0x0f44999c89997f6c;
const int RC_43_1 = 0x9cdad7826b51d247;
const int RC_43_2 = 0x883aa5997b8b948e;
const int RC_44_0 = 0x029384a42b89c8d7;
const int RC_44_1 = 0x344c73ef5721ac6d;
const int RC_44_2 = 0xdd481382be8d9392;
const int RC_45_0 = 0x8bb2cdd890932a2a;
const int RC_45_1 = 0x1c825723e7f1b6c8;
const int RC_45_2 = 0xc51ede98e6289208;
const int RC_46_0 = 0x5b496ccc5d2ca0cd;
const int RC_46_1 = 0xd37226eb936e62c1;
const int RC_46_2 = 0x582a00b4f2fec9f1;
const int RC_47_0 = 0x9d909c2d90b2cd0d;
const int RC_47_1 = 0xe6e856cd2b0860b1;
const int RC_47_2 = 0xff3a1dddb4689401;
const int RC_48_0 = 0xc8aecb68159e0557;
const int RC_48_1 = 0x348e3f981907d0cb;
const int RC_48_2 = 0x9468223d3507e6d8;
const int RC_49_0 = 0x0c46d9ff12c73a3a;
const int RC_49_1 = 0x947e999d7853e516;
const int RC_49_2 = 0x1c04ed5f5b065b35;
const int RC_50_0 = 0x470fe908d2043d2f;
const int RC_50_1 = 0x41178a5fe72ad21f;
const int RC_50_2 = 0x00c5d6b41658f874;
const int RC_51_0 = 0x13e4b86d5039b966;
const int RC_51_1 = 0xb32ad9eab5cb8c9b;
const int RC_51_2 = 0xce21068d03448c68;
const int RC_52_0 = 0x34c3bafc7cd8c031;
const int RC_52_1 = 0xf35743078820318f;
const int RC_52_2 = 0x814ebf2e9b7455fb;
const int RC_53_0 = 0xad484d59cc214ab7;
const int RC_53_1 = 0x7c54cd3ff4064b7d;
const int RC_53_2 = 0xe1b6cb2e30f6d8ff;
const int RC_54_0 = 0xdbbeb928c05ef8b4;
const int RC_54_1 = 0xee390e66d778a859;
const int RC_54_2 = 0xb5f39c0a1a9a2fc5;
const int RC_55_0 = 0x29f14da8b22ecb29;
const int RC_55_1 = 0x05364f2606b01de4;
const int RC_55_2 = 0x3442e0f4434bc4db;
const int RC_56_0 = 0x2a2ce301fa9946ad;
const int RC_56_1 = 0x669d17c448c3555a;
const int RC_56_2 = 0x086dcd9b0cac1fd7;
const int RC_57_0 = 0xbdab5c6249ab7933;
const int RC_57_1 = 0x3a5c5aae64991f0e;
const int RC_57_2 = 0x353fa75db6c7954c;
const int RC_58_0 = 0x9c07e452e08ba0f8;
const int RC_58_1 = 0x310dbb85fec2f6c0;
const int RC_58_2 = 0xd8dc21f5bb886aef;
const int RC_59_0 = 0x633156e94ebe8501;
const int RC_59_1 = 0x6535db82b7c5e602;
const int RC_59_2 = 0xef4d769f18a124fb;
const int RC_60_0 = 0x4152fb8544e2bc96;
const int RC_60_1 = 0x8ab2c440cc25aec5;
const int RC_60_2 = 0x75cbe6d3be23f42f;
const int RC_61_0 = 0xa96ec0494db528c3;
const int RC_61_1 = 0x32a29079c5075de3;
const int RC_61_2 = 0xfc4cb8b77fd00d9e;
const int RC_62_0 = 0xb98b621a705e846c;
const int RC_62_1 = 0xfa7fbb570307ba3c;
const int RC_62_2 = 0x41c2fbf000c75d82;
const int RC_63_0 = 0xbd58d1e32ed96709;
const int RC_63_1 = 0x5e5ceae82e700e55;
const int RC_63_2 = 0x795d667ad94ff175;
const int RC_64_0 = 0xb876b230415f2d1b;
const int RC_64_1 = 0x320f4be13abc3896;
const int RC_64_2 = 0xe4ea663b9a7c7094;

;; Modulus P0 = 2^252 + 27742317777372353535851937790883648493
const int M00 = 2;
const int M01 = 1;
const int M02 = 1;
const int M10 = 1;
const int M11 = 2;
const int M12 = 1;
const int M20 = 1;
const int M21 = 1;
const int M22 = 2;

;; ===========================================================
;; 2. Helper Functions
;; ===========================================================

;; Function to add two numbers modulo P0
;; Parameters:
;;   a - First operand
;;   b - Second operand
;; Returns:
;;   (a + b) mod P0
int add_mod(int a, int b) inline {
    return (a + b) % P0;
}

;; Function to multiply two numbers modulo P0
;; Parameters:
;;   a - First operand
;;   b - Second operand
;; Returns:
;;   (a * b) mod P0
int mul_mod(int a, int b) inline {
    return (a * b) % P0;
}

;; Function to raise a number to a power modulo P0
;; Parameters:
;;   base - The base number
;;   exp - The exponent
;; Returns:
;;   (base ^ exp) mod P0
int pow_mod(int base, int exp) inline {
    int result = 1;
    while (exp > 0) {
        if (exp & 1) {
            result = mul_mod(result, base);
        }
        base = mul_mod(base, base);
        exp >>= 1;
    }
    return result;
}

;; Function to apply the s-box transformation
;; Parameters:
;;   x - Input number
;; Returns:
;;   x raised to the power D modulo P0
int sbox(int x) inline {
    return pow_mod(x, D);
}

;; Function to get round constants for a given round
;; Parameters:
;;   round - The current round number
;; Returns:
;;   A tuple containing the three round constants for the round
(int, int, int) get_round_constants(int round) inline {
    if (round == 0) { return (RC_0_0, RC_0_1, RC_0_2); }
    if (round == 1) { return (RC_1_0, RC_1_1, RC_1_2); }
    if (round == 2) { return (RC_2_0, RC_2_1, RC_2_2); }
    if (round == 3) { return (RC_3_0, RC_3_1, RC_3_2); }
    if (round == 4) { return (RC_4_0, RC_4_1, RC_4_2); }
    if (round == 5) { return (RC_5_0, RC_5_1, RC_5_2); }
    if (round == 6) { return (RC_6_0, RC_6_1, RC_6_2); }
    if (round == 7) { return (RC_7_0, RC_7_1, RC_7_2); }
    if (round == 8) { return (RC_8_0, RC_8_1, RC_8_2); }
    if (round == 9) { return (RC_9_0, RC_9_1, RC_9_2); }
    if (round == 10) { return (RC_10_0, RC_10_1, RC_10_2); }
    if (round == 11) { return (RC_11_0, RC_11_1, RC_11_2); }
    if (round == 12) { return (RC_12_0, RC_12_1, RC_12_2); }
    if (round == 13) { return (RC_13_0, RC_13_1, RC_13_2); }
    if (round == 14) { return (RC_14_0, RC_14_1, RC_14_2); }
    if (round == 15) { return (RC_15_0, RC_15_1, RC_15_2); }
    if (round == 16) { return (RC_16_0, RC_16_1, RC_16_2); }
    if (round == 17) { return (RC_17_0, RC_17_1, RC_17_2); }
    if (round == 18) { return (RC_18_0, RC_18_1, RC_18_2); }
    if (round == 19) { return (RC_19_0, RC_19_1, RC_19_2); }
    if (round == 20) { return (RC_20_0, RC_20_1, RC_20_2); }
    if (round == 21) { return (RC_21_0, RC_21_1, RC_21_2); }
    if (round == 22) { return (RC_22_0, RC_22_1, RC_22_2); }
    if (round == 23) { return (RC_23_0, RC_23_1, RC_23_2); }
    if (round == 24) { return (RC_24_0, RC_24_1, RC_24_2); }
    if (round == 25) { return (RC_25_0, RC_25_1, RC_25_2); }
    if (round == 26) { return (RC_26_0, RC_26_1, RC_26_2); }
    if (round == 27) { return (RC_27_0, RC_27_1, RC_27_2); }
    if (round == 28) { return (RC_28_0, RC_28_1, RC_28_2); }
    if (round == 29) { return (RC_29_0, RC_29_1, RC_29_2); }
    if (round == 30) { return (RC_30_0, RC_30_1, RC_30_2); }
    if (round == 31) { return (RC_31_0, RC_31_1, RC_31_2); }
    if (round == 32) { return (RC_32_0, RC_32_1, RC_32_2); }
    if (round == 33) { return (RC_33_0, RC_33_1, RC_33_2); }
    if (round == 34) { return (RC_34_0, RC_34_1, RC_34_2); }
    if (round == 35) { return (RC_35_0, RC_35_1, RC_35_2); }
    if (round == 36) { return (RC_36_0, RC_36_1, RC_36_2); }
    if (round == 37) { return (RC_37_0, RC_37_1, RC_37_2); }
    if (round == 38) { return (RC_38_0, RC_38_1, RC_38_2); }
    if (round == 39) { return (RC_39_0, RC_39_1, RC_39_2); }
    if (round == 40) { return (RC_40_0, RC_40_1, RC_40_2); }
    if (round == 41) { return (RC_41_0, RC_41_1, RC_41_2); }
    if (round == 42) { return (RC_42_0, RC_42_1, RC_42_2); }
    if (round == 43) { return (RC_43_0, RC_43_1, RC_43_2); }
    if (round == 44) { return (RC_44_0, RC_44_1, RC_44_2); }
    if (round == 45) { return (RC_45_0, RC_45_1, RC_45_2); }
    if (round == 46) { return (RC_46_0, RC_46_1, RC_46_2); }
    if (round == 47) { return (RC_47_0, RC_47_1, RC_47_2); }
    if (round == 48) { return (RC_48_0, RC_48_1, RC_48_2); }
    if (round == 49) { return (RC_49_0, RC_49_1, RC_49_2); }
    if (round == 50) { return (RC_50_0, RC_50_1, RC_50_2); }
    if (round == 51) { return (RC_51_0, RC_51_1, RC_51_2); }
    if (round == 52) { return (RC_52_0, RC_52_1, RC_52_2); }
    if (round == 53) { return (RC_53_0, RC_53_1, RC_53_2); }
    if (round == 54) { return (RC_54_0, RC_54_1, RC_54_2); }
    if (round == 55) { return (RC_55_0, RC_55_1, RC_55_2); }
    if (round == 56) { return (RC_56_0, RC_56_1, RC_56_2); }
    if (round == 57) { return (RC_57_0, RC_57_1, RC_57_2); }
    if (round == 58) { return (RC_58_0, RC_58_1, RC_58_2); }
    if (round == 59) { return (RC_59_0, RC_59_1, RC_59_2); }
    if (round == 60) { return (RC_60_0, RC_60_1, RC_60_2); }
    if (round == 61) { return (RC_61_0, RC_61_1, RC_61_2); }
    if (round == 62) { return (RC_62_0, RC_62_1, RC_62_2); }
    if (round == 63) { return (RC_63_0, RC_63_1, RC_63_2); }
    if (round == 64) { return (RC_64_0, RC_64_1, RC_64_2); }
    return (0, 0, 0); ;; Default case, should never happen
}

;; This function performs an optimized matrix multiplication.
(int, int, int) matrix_mul_optimized(int x0, int x1, int x2) inline {
    int y0 = add_mod(mul_mod(M00, x0), add_mod(mul_mod(M01, x1), mul_mod(M02, x2)));
    int y1 = add_mod(mul_mod(M10, x0), add_mod(mul_mod(M11, x1), mul_mod(M12, x2)));
    int y2 = add_mod(mul_mod(M20, x0), add_mod(mul_mod(M21, x1), mul_mod(M22, x2)));
    return (y0, y1, y2);
}

;; ===========================================================
;; 3. Poseidon2 Permutation
;; ===========================================================

;; This function applies the Poseidon2 permutation to the input state.
;; Parameters:
;;   s0, s1, s2 - Current state elements
;; Returns:
;;   Updated state as a tuple
(int, int, int) poseidon2_permutation(int s0, int s1, int s2) {
    int a = 0;
    int q0 = 0;
    int q1 = 0;

    (s0, s1, s2) = matrix_mul_optimized(s0, s1, s2);

    int i = 0;
    while (i < TOTAL_ROUNDS) {
        (int rc0, int rc1, int rc2) = get_round_constants(i);
        s0 = add_mod(s0, rc0);

        int s = sbox(s0);

        a = add_mod(a, s);
        a = add_mod(a, P0 - q1);
        q1 = q0;
        q0 = s;

        ;; Rotate the state
        ;; Since FunC does not support tuple rotation directly, reassign individually
        int temp = s0;
        s0 = s1;
        s1 = s2;
        s2 = temp;

        s0 = add_mod(s0, a);

        ;; Use bitwise OR for logical conditions
        if ((i < RF / 2) | (i >= RF / 2 + RP)) {
            s1 = sbox(s1);
            s2 = sbox(s2);
            (s0, s1, s2) = matrix_mul_optimized(s0, s1, s2);
        }

        i += 1;
    }

    s1 = add_mod(s1, q0);
    s2 = add_mod(s2, q1);

    return (s0, s1, s2);
}

;; ===========================================================
;; 4. Poseidon2 Hash Function
;; ===========================================================

;; Poseidon2 hash function returning a tuple representing a 256-bit hash
;; Parameters:
;;   inputs - Tuple of input elements
;;   input_len - Number of input elements
;; Returns:
;;   A tuple representing the 256-bit hash
(int, int, int, int) poseidon2_hash(tuple inputs, int input_len) {
    int s0 = 0;
    int s1 = 0;
    int s2 = 0;

    int i = 0;
    while (i < input_len) {
        s0 = add_mod(s0, inputs.at(i));
        i += 1;
        if (i < input_len) {
            s1 = add_mod(s1, inputs.at(i));
            i += 1;
        }
        (s0, s1, s2) = poseidon2_permutation(s0, s1, s2);
    }

    ;; Initialize the fourth limb (s3) as zero or based on your Poseidon2 design
    int s3 = 0;
    return (s0, s1, s2, s3);
}

;; ===========================================================
;; 5. Message Handling
;; ===========================================================

;; Simple throw_if implementation
;; Parameters:
;;   error_code - The error code to throw if the condition is true
;;   condition - The condition to evaluate
void throw_if(int error_code, bool condition) {
    if (condition) {
        throw(error_code);
    }
}

;; Returns a tuple of 32-bit integers
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    ;; Operation code for receiving a message
    int op = in_msg_body~load_uint(32);
    if (op == 1) {  ;; Verify hash operation
        int num_inputs = in_msg_body~load_uint(32);
        
        ;; Input Validation (check if inputs are valid)
        if ((num_inputs < 0) | (num_inputs > MAX_ALLOWED_INPUTS)) {
            throw(0x0001); ;; Error code for invalid number of inputs
        }

        ;; Inputs Validation (check if inputs are valid)
        tuple inputs = empty_tuple();
        repeat(num_inputs) {
            inputs~tpush(in_msg_body~load_uint(64));
        }
        
        ;; Expected Hash (load expected hash from the message)
        int expected_hash_part1 = in_msg_body~load_uint(64);
        int expected_hash_part2 = in_msg_body~load_uint(64);
        int expected_hash_part3 = in_msg_body~load_uint(64);
        int expected_hash_part4 = in_msg_body~load_uint(64);

        ;; Compute the Poseidon2 hash
        (int calculated_hash_part1, int calculated_hash_part2, int calculated_hash_part3, int calculated_hash_part4) = poseidon2_hash(inputs, num_inputs);

        ;; Verification Result: Compare each limb
        ;; FunC does not support logical AND (&&), so use bitwise AND (&)
        bool is_valid = ((calculated_hash_part1 == expected_hash_part1) &
                         (calculated_hash_part2 == expected_hash_part2) &
                         (calculated_hash_part3 == expected_hash_part3) &
                         (calculated_hash_part4 == expected_hash_part4)) ? 1 : 0;

        ;; Construct Response Message with each limb and verification result
        cell msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce flag
            .store_uint(op, 32)  ;; original operation code
            .store_uint(calculated_hash_part1, 64)  ;; computed hash limb 1
            .store_uint(calculated_hash_part2, 64)  ;; computed hash limb 2
            .store_uint(calculated_hash_part3, 64)  ;; computed hash limb 3
            .store_uint(calculated_hash_part4, 64)  ;; computed hash limb 4
            .store_uint(expected_hash_part1, 64)    ;; expected hash limb 1
            .store_uint(expected_hash_part2, 64)    ;; expected hash limb 2
            .store_uint(expected_hash_part3, 64)    ;; expected hash limb 3
            .store_uint(expected_hash_part4, 64)    ;; expected hash limb 4
            .store_uint(is_valid, 1)                ;; verification result
            .end_cell();
        
        ;; Send Response Message
        send_raw_message(msg, 64);
        return ();
    }

    ;; Unsupported Operation
    throw(0xffff);
}

;; ===========================================================
;; 6. Testing
;; ===========================================================

;; Test function
() run_tests() {
    ;; Test Case 1: Simple input
    tuple test_inputs1 = empty_tuple();
    test_inputs1~tpush(1);
    test_inputs1~tpush(2);
    test_inputs1~tpush(3);
    (int hash_result1_part1, int hash_result1_part2, int hash_result1_part3, int hash_result1_part4) = poseidon2_hash(test_inputs1, 3);
    int expected_hash1_part1 = 0x123456789ABCDEF0; ;; Replace with actual expected value
    int expected_hash1_part2 = 0x123456789ABCDEF0; ;; Replace with actual expected value
    int expected_hash1_part3 = 0x123456789ABCDEF0; ;; Replace with actual expected value
    int expected_hash1_part4 = 0x123456789ABCDEF0; ;; Replace with actual expected value
    throw_if(100, (hash_result1_part1 != expected_hash1_part1) | 
                   (hash_result1_part2 != expected_hash1_part2) | 
                   (hash_result1_part3 != expected_hash1_part3) | 
                   (hash_result1_part4 != expected_hash1_part4));

    ;; Test Case 2: Empty input
    tuple test_inputs2 = empty_tuple();
    (int hash_result2_part1, int hash_result2_part2, int hash_result2_part3, int hash_result2_part4) = poseidon2_hash(test_inputs2, 0);
    int expected_hash2_part1 = 0xFEDCBA9876543210; ;; Replace with actual expected value
    int expected_hash2_part2 = 0xFEDCBA9876543210; ;; Replace with actual expected value
    int expected_hash2_part3 = 0xFEDCBA9876543210; ;; Replace with actual expected value
    int expected_hash2_part4 = 0xFEDCBA9876543210; ;; Replace with actual expected value
    throw_if(101, (hash_result2_part1 != expected_hash2_part1) | 
                   (hash_result2_part2 != expected_hash2_part2) | 
                   (hash_result2_part3 != expected_hash2_part3) | 
                   (hash_result2_part4 != expected_hash2_part4));

    ;; Test Case 3: Single element
    tuple test_inputs3 = empty_tuple();
    test_inputs3~tpush(42);
    (int hash_result3_part1, int hash_result3_part2, int hash_result3_part3, int hash_result3_part4) = poseidon2_hash(test_inputs3, 1);
    int expected_hash3_part1 = 0xAABBCCDDEEFF0011; ;; Replace with actual expected value
    int expected_hash3_part2 = 0xAABBCCDDEEFF0011; ;; Replace with actual expected value
    int expected_hash3_part3 = 0xAABBCCDDEEFF0011; ;; Replace with actual expected value
    int expected_hash3_part4 = 0xAABBCCDDEEFF0011; ;; Replace with actual expected value
    throw_if(102, (hash_result3_part1 != expected_hash3_part1) | 
                   (hash_result3_part2 != expected_hash3_part2) | 
                   (hash_result3_part3 != expected_hash3_part3) | 
                   (hash_result3_part4 != expected_hash3_part4));

    ;; Add more test cases as needed

    ;; Log Success
    ;; Note: Ensure that the ~dump function is supported in your environment.
    ;; If not, consider alternative logging mechanisms.
    ~dump("All tests passed successfully.");
}

;; ===========================================================
;; 7. Entrypoint
;; ===========================================================

;; Entry point
() entrypoint() {
    int msg_value = 0;
    cell in_msg_full = begin_cell()
        .store_uint(0x10, 6)
        .end_cell();
    slice in_msg_body = in_msg_full.begin_parse();
    recv_internal(msg_value, in_msg_full, in_msg_body);
    run_tests();
}
</code></pre>
<p></p>
