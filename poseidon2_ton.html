<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poseidon2 on TON</title>
    <style>
        body {
            background-color: #000000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        h1 {
            font-family: 'VT323', monospace;
            text-align: center;
            font-size: 3em;
            text-shadow: 0 0 10px #00ff0091;
        }
        pre {
            background-color: #0a0a0a;
            border: 1px solid #00ff00;
            padding: 20px;
            overflow-x: auto;
        }
        code {
            color: #0dbd0d;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
</head>
<body>
    <h1>Poseidon2 on TON</h1>
    <pre><code>
</body>
</html>
;; ===========================================================
;; Poseidon2 Hash Function Implementation in FunC for TON
;; ===========================================================
;; Author: Cryptskii
;; Date: 2024-09-16
;; Description:
;; This smart contract implements the Poseidon2 cryptographic 
;; hash function optimized for the TON blockchain.
;; It includes multi-limb arithmetic to handle 256-bit 
;; integers, modular operations, and the Poseidon sponge 
;; construction.
;; ===========================================================
#include "imports/stdlib.fc";
;; ===========================================================
;; 1. Constants and Parameters
;; ===========================================================

const int LIMB_SIZE = 64;  ;; Size of each limb in bits
const int NUM_LIMBS = 4;   ;; Number of limbs for 256-bit integers

;; Poseidon2 parameters
const int T = 4;  ;; State size
const int RATE = 2;  ;; Number of inputs absorbed per permutation
const int CAPACITY = 2;  ;; T - RATE
const int D = 5;  ;; S-box power
const int RF_FULL = 8;  ;; Full rounds
const int RP_PARTIAL = 56;  ;; Partial rounds
const int TOTAL_ROUNDS = RF_FULL + RP_PARTIAL;

;; Field modulus Goldilocks prime in limbs
const int P0_0 = 0xFFFFFFFF;  ;; Least significant limb
const int P0_1 = 0xFFFFFFFF;
const int P0_2 = 0xFFFFFFFF;
const int P0_3 = 0x00000000;  ;; Most significant limb

;; MDS Matrix Constants
const int M00 = 2; const int M01 = 1; const int M02 = 1; const int M03 = 1;
const int M10 = 1; const int M11 = 2; const int M12 = 1; const int M13 = 1;
const int M20 = 1; const int M21 = 1; const int M22 = 2; const int M23 = 1;
const int M30 = 1; const int M31 = 1; const int M32 = 1; const int M33 = 2;

;; Montgomery Reduction Constants
const int R_INV = 0x000000000000000000000000003ACAE13F5787ECF817CD232508BB25766665D6;
const int N_PRIME = 0xDDB81602A679B58B90DF74D5295664F6016E02DFAF9F3E46E84824C81710FEF1;

;; Round constants 
const int RC_00_00 = 0x0043E1F593F0000001ABCDEF;
const int RC_00_01 = 0x0043E1F593F0000001ABCDF0;
const int RC_00_02 = 0x0043E1F593F0000001ABCDF1;
const int RC_00_03 = 0x0043E1F593F0000001ABCDF2;
const int RC_01_00 = 0x0043E1F593F0000001ABCDF3;
const int RC_01_01 = 0x0043E1F593F0000001ABCDF4;
const int RC_01_02 = 0x0043E1F593F0000001ABCDF5;
const int RC_01_03 = 0x0043E1F593F0000001ABCDF6;
const int RC_02_00 = 0x0043E1F593F0000001ABCDF7;
const int RC_02_01 = 0x0043E1F593F0000001ABCDF8;
const int RC_02_02 = 0x0043E1F593F0000001ABCDF9;
const int RC_02_03 = 0x0043E1F593F0000001ABCDFA;
const int RC_03_00 = 0x0043E1F593F0000001ABCDFB;
const int RC_03_01 = 0x0043E1F593F0000001ABCDFC;
const int RC_03_02 = 0x0043E1F593F0000001ABCDFD;
const int RC_03_03 = 0x0043E1F593F0000001ABCDFE;
const int RC_04_00 = 0x0043E1F593F0000001ABCDFF;
const int RC_04_01 = 0x0043E1F593F0000001ABCE00;
const int RC_04_02 = 0x0043E1F593F0000001ABCE01;
const int RC_04_03 = 0x0043E1F593F0000001ABCE02;
const int RC_05_00 = 0x0043E1F593F0000001ABCE03;
const int RC_05_01 = 0x0043E1F593F0000001ABCE04;
const int RC_05_02 = 0x0043E1F593F0000001ABCE05;
const int RC_05_03 = 0x0043E1F593F0000001ABCE06;
const int RC_06_00 = 0x0043E1F593F0000001ABCE07;
const int RC_06_01 = 0x0043E1F593F0000001ABCE08;
const int RC_06_02 = 0x0043E1F593F0000001ABCE09;
const int RC_06_03 = 0x0043E1F593F0000001ABCE0A;
const int RC_07_00 = 0x0043E1F593F0000001ABCE0B;
const int RC_07_01 = 0x0043E1F593F0000001ABCE0C;
const int RC_07_02 = 0x0043E1F593F0000001ABCE0D;
const int RC_07_03 = 0x0043E1F593F0000001ABCE0E;
const int RC_08_00 = 0x0043E1F593F0000001ABCE0F;
const int RC_08_01 = 0x0043E1F593F0000001ABCE10;
const int RC_08_02 = 0x0043E1F593F0000001ABCE11;
const int RC_08_03 = 0x0043E1F593F0000001ABCE12;
const int RC_09_00 = 0x0043E1F593F0000001ABCE13;
const int RC_09_01 = 0x0043E1F593F0000001ABCE14;
const int RC_09_02 = 0x0043E1F593F0000001ABCE15;
const int RC_09_03 = 0x0043E1F593F0000001ABCE16;
const int RC_10_00 = 0x0043E1F593F0000001ABCE17;
const int RC_10_01 = 0x0043E1F593F0000001ABCE18;
const int RC_10_02 = 0x0043E1F593F0000001ABCE19;
const int RC_10_03 = 0x0043E1F593F0000001ABCE1A;
const int RC_11_00 = 0x0043E1F593F0000001ABCE1B;
const int RC_11_01 = 0x0043E1F593F0000001ABCE1C;
const int RC_11_02 = 0x0043E1F593F0000001ABCE1D;
const int RC_11_03 = 0x0043E1F593F0000001ABCE1E;
const int RC_12_00 = 0x0043E1F593F0000001ABCE1F;
const int RC_12_01 = 0x0043E1F593F0000001ABCE20;
const int RC_12_02 = 0x0043E1F593F0000001ABCE21;
const int RC_12_03 = 0x0043E1F593F0000001ABCE22;
const int RC_13_00 = 0x0043E1F593F0000001ABCE23;
const int RC_13_01 = 0x0043E1F593F0000001ABCE24;
const int RC_13_02 = 0x0043E1F593F0000001ABCE25;
const int RC_13_03 = 0x0043E1F593F0000001ABCE26;
const int RC_14_00 = 0x0043E1F593F0000001ABCE27;
const int RC_14_01 = 0x0043E1F593F0000001ABCE28;
const int RC_14_02 = 0x0043E1F593F0000001ABCE29;
const int RC_14_03 = 0x0043E1F593F0000001ABCE2A;
const int RC_15_00 = 0x0043E1F593F0000001ABCE2B;
const int RC_15_01 = 0x0043E1F593F0000001ABCE2C;
const int RC_15_02 = 0x0043E1F593F0000001ABCE2D;
const int RC_15_03 = 0x0043E1F593F0000001ABCE2E;
const int RC_16_00 = 0x0043E1F593F0000001ABCE2F;
const int RC_16_01 = 0x0043E1F593F0000001ABCE30;
const int RC_16_02 = 0x0043E1F593F0000001ABCE31;
const int RC_16_03 = 0x0043E1F593F0000001ABCE32;
const int RC_17_00 = 0x0043E1F593F0000001ABCE33;
const int RC_17_01 = 0x0043E1F593F0000001ABCE34;
const int RC_17_02 = 0x0043E1F593F0000001ABCE35;
const int RC_17_03 = 0x0043E1F593F0000001ABCE36;
const int RC_18_00 = 0x0043E1F593F0000001ABCE37;
const int RC_18_01 = 0x0043E1F593F0000001ABCE38;
const int RC_18_02 = 0x0043E1F593F0000001ABCE39;
const int RC_18_03 = 0x0043E1F593F0000001ABCE3A;
const int RC_19_00 = 0x0043E1F593F0000001ABCE3B;
const int RC_19_01 = 0x0043E1F593F0000001ABCE3C;
const int RC_19_02 = 0x0043E1F593F0000001ABCE3D;
const int RC_19_03 = 0x0043E1F593F0000001ABCE3E;
const int RC_20_00 = 0x0043E1F593F0000001ABCE3F;
const int RC_20_01 = 0x0043E1F593F0000001ABCE40;
const int RC_20_02 = 0x0043E1F593F0000001ABCE41;
const int RC_20_03 = 0x0043E1F593F0000001ABCE42;
const int RC_21_00 = 0x0043E1F593F0000001ABCE43;
const int RC_21_01 = 0x0043E1F593F0000001ABCE44;
const int RC_21_02 = 0x0043E1F593F0000001ABCE45;
const int RC_21_03 = 0x0043E1F593F0000001ABCE46;
const int RC_22_00 = 0x0043E1F593F0000001ABCE47;
const int RC_22_01 = 0x0043E1F593F0000001ABCE48;
const int RC_22_02 = 0x0043E1F593F0000001ABCE49;
const int RC_22_03 = 0x0043E1F593F0000001ABCE4A;
const int RC_23_00 = 0x0043E1F593F0000001ABCE4B;
const int RC_23_01 = 0x0043E1F593F0000001ABCE4C;
const int RC_23_02 = 0x0043E1F593F0000001ABCE4D;
const int RC_23_03 = 0x0043E1F593F0000001ABCE4E;
const int RC_24_00 = 0x0043E1F593F0000001ABCE4F;
const int RC_24_01 = 0x0043E1F593F0000001ABCE50;
const int RC_24_02 = 0x0043E1F593F0000001ABCE51;
const int RC_24_03 = 0x0043E1F593F0000001ABCE52;
const int RC_25_00 = 0x0043E1F593F0000001ABCE53;
const int RC_25_01 = 0x0043E1F593F0000001ABCE54;
const int RC_25_02 = 0x0043E1F593F0000001ABCE55;
const int RC_25_03 = 0x0043E1F593F0000001ABCE56;
const int RC_26_00 = 0x0043E1F593F0000001ABCE57;
const int RC_26_01 = 0x0043E1F593F0000001ABCE58;
const int RC_26_02 = 0x0043E1F593F0000001ABCE59;
const int RC_26_03 = 0x0043E1F593F0000001ABCE5A;
const int RC_27_00 = 0x0043E1F593F0000001ABCE5B;
const int RC_27_01 = 0x0043E1F593F0000001ABCE5C;
const int RC_27_02 = 0x0043E1F593F0000001ABCE5D;
const int RC_27_03 = 0x0043E1F593F0000001ABCE5E;
const int RC_28_00 = 0x0043E1F593F0000001ABCE5F;
const int RC_28_01 = 0x0043E1F593F0000001ABCE60;
const int RC_28_02 = 0x0043E1F593F0000001ABCE61;
const int RC_28_03 = 0x0043E1F593F0000001ABCE62;
const int RC_29_00 = 0x0043E1F593F0000001ABCE63;
const int RC_29_01 = 0x0043E1F593F0000001ABCE64;
const int RC_29_02 = 0x0043E1F593F0000001ABCE65;
const int RC_29_03 = 0x0043E1F593F0000001ABCE66;
const int RC_30_00 = 0x0043E1F593F0000001ABCE67;
const int RC_30_01 = 0x0043E1F593F0000001ABCE68;
const int RC_30_02 = 0x0043E1F593F0000001ABCE69;
const int RC_30_03 = 0x0043E1F593F0000001ABCE6A;
const int RC_31_00 = 0x0043E1F593F0000001ABCE6B;
const int RC_31_01 = 0x0043E1F593F0000001ABCE6C;
const int RC_31_02 = 0x0043E1F593F0000001ABCE6D;
const int RC_31_03 = 0x0043E1F593F0000001ABCE6E;
const int RC_32_00 = 0x0043E1F593F0000001ABCE6F;
const int RC_32_01 = 0x0043E1F593F0000001ABCE70;
const int RC_32_02 = 0x0043E1F593F0000001ABCE71;
const int RC_32_03 = 0x0043E1F593F0000001ABCE72;
const int RC_33_00 = 0x0043E1F593F0000001ABCE73;
const int RC_33_01 = 0x0043E1F593F0000001ABCE74;
const int RC_33_02 = 0x0043E1F593F0000001ABCE75;
const int RC_33_03 = 0x0043E1F593F0000001ABCE76;
const int RC_34_00 = 0x0043E1F593F0000001ABCE77;
const int RC_34_01 = 0x0043E1F593F0000001ABCE78;
const int RC_34_02 = 0x0043E1F593F0000001ABCE79;
const int RC_34_03 = 0x0043E1F593F0000001ABCE7A;
const int RC_35_00 = 0x0043E1F593F0000001ABCE7B;
const int RC_35_01 = 0x0043E1F593F0000001ABCE7C;
const int RC_35_02 = 0x0043E1F593F0000001ABCE7D;
const int RC_35_03 = 0x0043E1F593F0000001ABCE7E;
const int RC_36_00 = 0x0043E1F593F0000001ABCE7F;
const int RC_36_01 = 0x0043E1F593F0000001ABCE80;
const int RC_36_02 = 0x0043E1F593F0000001ABCE81;
const int RC_36_03 = 0x0043E1F593F0000001ABCE82;
const int RC_37_00 = 0x0043E1F593F0000001ABCE83;
const int RC_37_01 = 0x0043E1F593F0000001ABCE84;
const int RC_37_02 = 0x0043E1F593F0000001ABCE85;
const int RC_37_03 = 0x0043E1F593F0000001ABCE86;
const int RC_38_00 = 0x0043E1F593F0000001ABCE87;
const int RC_38_01 = 0x0043E1F593F0000001ABCE88;
const int RC_38_02 = 0x0043E1F593F0000001ABCE89;
const int RC_38_03 = 0x0043E1F593F0000001ABCE8A;
const int RC_39_00 = 0x0043E1F593F0000001ABCE8B;
const int RC_39_01 = 0x0043E1F593F0000001ABCE8C;
const int RC_39_02 = 0x0043E1F593F0000001ABCE8D;
const int RC_39_03 = 0x0043E1F593F0000001ABCE8E;
const int RC_40_00 = 0x0043E1F593F0000001ABCE8F;
const int RC_40_01 = 0x0043E1F593F0000001ABCE90;
const int RC_40_02 = 0x0043E1F593F0000001ABCE91;
const int RC_40_03 = 0x0043E1F593F0000001ABCE92;
const int RC_41_00 = 0x0043E1F593F0000001ABCE93;
const int RC_41_01 = 0x0043E1F593F0000001ABCE94;
const int RC_41_02 = 0x0043E1F593F0000001ABCE95;
const int RC_41_03 = 0x0043E1F593F0000001ABCE96;
const int RC_42_00 = 0x0043E1F593F0000001ABCE97;
const int RC_42_01 = 0x0043E1F593F0000001ABCE98;
const int RC_42_02 = 0x0043E1F593F0000001ABCE99;
const int RC_42_03 = 0x0043E1F593F0000001ABCE9A;
const int RC_43_00 = 0x0043E1F593F0000001ABCE9B;
const int RC_43_01 = 0x0043E1F593F0000001ABCE9C;
const int RC_43_02 = 0x0043E1F593F0000001ABCE9D;
const int RC_43_03 = 0x0043E1F593F0000001ABCE9E;
const int RC_44_00 = 0x0043E1F593F0000001ABCE9F;
const int RC_44_01 = 0x0043E1F593F0000001ABCEA0;
const int RC_44_02 = 0x0043E1F593F0000001ABCEA1;
const int RC_44_03 = 0x0043E1F593F0000001ABCEA2;
const int RC_45_00 = 0x0043E1F593F0000001ABCEA3;
const int RC_45_01 = 0x0043E1F593F0000001ABCEA4;
const int RC_45_02 = 0x0043E1F593F0000001ABCEA5;
const int RC_45_03 = 0x0043E1F593F0000001ABCEA6;
const int RC_46_00 = 0x0043E1F593F0000001ABCEA7;
const int RC_46_01 = 0x0043E1F593F0000001ABCEA8;
const int RC_46_02 = 0x0043E1F593F0000001ABCEA9;
const int RC_46_03 = 0x0043E1F593F0000001ABCEAA;
const int RC_47_00 = 0x0043E1F593F0000001ABCEAB;
const int RC_47_01 = 0x0043E1F593F0000001ABCEAC;
const int RC_47_02 = 0x0043E1F593F0000001ABCEAD;
const int RC_47_03 = 0x0043E1F593F0000001ABCEAE;
const int RC_48_00 = 0x0043E1F593F0000001ABCEAF;
const int RC_48_01 = 0x0043E1F593F0000001ABCEB0;
const int RC_48_02 = 0x0043E1F593F0000001ABCEB1;
const int RC_48_03 = 0x0043E1F593F0000001ABCEB2;
const int RC_49_00 = 0x0043E1F593F0000001ABCEB3;
const int RC_49_01 = 0x0043E1F593F0000001ABCEB4;
const int RC_49_02 = 0x0043E1F593F0000001ABCEB5;
const int RC_49_03 = 0x0043E1F593F0000001ABCEB6;
const int RC_50_00 = 0x0043E1F593F0000001ABCEB7;
const int RC_50_01 = 0x0043E1F593F0000001ABCEB8;
const int RC_50_02 = 0x0043E1F593F0000001ABCEB9;
const int RC_50_03 = 0x0043E1F593F0000001ABCEBA;
const int RC_51_00 = 0x0043E1F593F0000001ABCEBB;
const int RC_51_01 = 0x0043E1F593F0000001ABCEBC;
const int RC_51_02 = 0x0043E1F593F0000001ABCEBD;
const int RC_51_03 = 0x0043E1F593F0000001ABCEBE;
const int RC_52_00 = 0x0043E1F593F0000001ABCEBF;
const int RC_52_01 = 0x0043E1F593F0000001ABCEC0;
const int RC_52_02 = 0x0043E1F593F0000001ABCEC1;
const int RC_52_03 = 0x0043E1F593F0000001ABCEC2;
const int RC_53_00 = 0x0043E1F593F0000001ABCEC3;
const int RC_53_01 = 0x0043E1F593F0000001ABCEC4;
const int RC_53_02 = 0x0043E1F593F0000001ABCEC5;
const int RC_53_03 = 0x0043E1F593F0000001ABCEC6;
const int RC_54_00 = 0x0043E1F593F0000001ABCEC7;
const int RC_54_01 = 0x0043E1F593F0000001ABCEC8;
const int RC_54_02 = 0x0043E1F593F0000001ABCEC9;
const int RC_54_03 = 0x0043E1F593F0000001ABCECA;
const int RC_55_00 = 0x0043E1F593F0000001ABCECB;
const int RC_55_01 = 0x0043E1F593F0000001ABCECC;
const int RC_55_02 = 0x0043E1F593F0000001ABCECD;
const int RC_55_03 = 0x0043E1F593F0000001ABCECE;
const int RC_56_00 = 0x0043E1F593F0000001ABCECF;
const int RC_56_01 = 0x0043E1F593F0000001ABCED0;
const int RC_56_02 = 0x0043E1F593F0000001ABCED1;
const int RC_56_03 = 0x0043E1F593F0000001ABCED2;
const int RC_57_00 = 0x0043E1F593F0000001ABCED3;
const int RC_57_01 = 0x0043E1F593F0000001ABCED4;
const int RC_57_02 = 0x0043E1F593F0000001ABCED5;
const int RC_57_03 = 0x0043E1F593F0000001ABCED6;
const int RC_58_00 = 0x0043E1F593F0000001ABCED7;
const int RC_58_01 = 0x0043E1F593F0000001ABCED8;
const int RC_58_02 = 0x0043E1F593F0000001ABCED9;
const int RC_58_03 = 0x0043E1F593F0000001ABCEDA;
const int RC_59_00 = 0x0043E1F593F0000001ABCEDB;
const int RC_59_01 = 0x0043E1F593F0000001ABCEDC;
const int RC_59_02 = 0x0043E1F593F0000001ABCEDD;
const int RC_59_03 = 0x0043E1F593F0000001ABCEDE;
const int RC_60_00 = 0x0043E1F593F0000001ABCEDF;
const int RC_60_01 = 0x0043E1F593F0000001ABCEE0;
const int RC_60_02 = 0x0043E1F593F0000001ABCEE1;
const int RC_60_03 = 0x0043E1F593F0000001ABCEE2;
const int RC_61_00 = 0x0043E1F593F0000001ABCEE3;
const int RC_61_01 = 0x0043E1F593F0000001ABCEE4;
const int RC_61_02 = 0x0043E1F593F0000001ABCEE5;
const int RC_61_03 = 0x0043E1F593F0000001ABCEE6;
const int RC_62_00 = 0x0043E1F593F0000001ABCEE7;
const int RC_62_01 = 0x0043E1F593F0000001ABCEE8;
const int RC_62_02 = 0x0043E1F593F0000001ABCEE9;
const int RC_62_03 = 0x0043E1F593F0000001ABCEEA;
const int RC_63_00 = 0x0043E1F593F0000001ABCEEB;
const int RC_63_01 = 0x0043E1F593F0000001ABCEEC;
const int RC_63_02 = 0x0043E1F593F0000001ABCEED;
const int RC_63_03 = 0x0043E1F593F0000001ABCEEE;

;; ===========================================================
;; 2. Helper Functions
;; ===========================================================

;; Add two multi-limb numbers with modular reduction
(int, int, int, int) add_mod_limbs(int a0, int a1, int a2, int a3, int b0, int b1, int b2, int b3) inline {
    int c0 = a0 + b0;
    int c1 = a1 + b1 + (c0 >> LIMB_SIZE);
    int c2 = a2 + b2 + (c1 >> LIMB_SIZE);
    int c3 = a3 + b3 + (c2 >> LIMB_SIZE);
    
    c0 &= ((1 << LIMB_SIZE) - 1);
    c1 &= ((1 << LIMB_SIZE) - 1);
    c2 &= ((1 << LIMB_SIZE) - 1);
    
    ;; Modular reduction
    if (c3 > P0_3) | ((c3 == P0_3) & ((c2 > P0_2) | ((c2 == P0_2) & ((c1 > P0_1) | ((c1 == P0_1) & (c0 >= P0_0)))))) {
        (int nc0, int nc1, int nc2, int nc3) = add_mod_limbs(c0, c1, c2, c3, (~ P0_0) + 1, (~ P0_1) + 1, (~ P0_2) + 1, (~ P0_3) + 1);
        return (nc0, nc1, nc2, nc3);
    }
    
    return (c0, c1, c2, c3);
}

;; Multiply two multi-limb numbers with modular reduction
(int, int, int, int) mul_mod_limbs(int a0, int a1, int a2, int a3, int b0, int b1, int b2, int b3) inline {
    ;; Perform full multiplication
    int c0 = a0 * b0;
    int c1 = a0 * b1 + a1 * b0;
    int c2 = a0 * b2 + a1 * b1 + a2 * b0;
    int c3 = a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;
    int c4 = a1 * b3 + a2 * b2 + a3 * b1;
    int c5 = a2 * b3 + a3 * b2;
    int c6 = a3 * b3;

    ;; Perform carry propagation
    c1 += c0 >> LIMB_SIZE;
    c0 &= ((1 << LIMB_SIZE) - 1);
    c2 += c1 >> LIMB_SIZE;
    c1 &= ((1 << LIMB_SIZE) - 1);
    c3 += c2 >> LIMB_SIZE;
    c2 &= ((1 << LIMB_SIZE) - 1);
    c4 += c3 >> LIMB_SIZE;
    c3 &= ((1 << LIMB_SIZE) - 1);
    c5 += c4 >> LIMB_SIZE;
    c4 &= ((1 << LIMB_SIZE) - 1);
    c6 += c5 >> LIMB_SIZE;
    c5 &= ((1 << LIMB_SIZE) - 1);

    ;; Perform modular reduction
    ;; Using the fact that 2^256 â‰¡ 1 (mod p) for Goldilocks prime
    (int r0, int r1, int r2, int r3) = add_mod_limbs(c0, c1, c2, c3, c4, c5, c6, 0);

    return (r0, r1, r2, r3);
}

;; Poseidon2 S-box (x^5 mod p)
(int, int, int, int) sbox_limbs(int x0, int x1, int x2, int x3) inline {
    ;; x^2
    (int x2_0, int x2_1, int x2_2, int x2_3) = mul_mod_limbs(x0, x1, x2, x3, x0, x1, x2, x3);
    
    ;; x^4
    (int x4_0, int x4_1, int x4_2, int x4_3) = mul_mod_limbs(x2_0, x2_1, x2_2, x2_3, x2_0, x2_1, x2_2, x2_3);
    
    ;; x^5
    return mul_mod_limbs(x4_0, x4_1, x4_2, x4_3, x0, x1, x2, x3);
}

;; Get round constant (implement a more efficient lookup method in practice)
(int, int, int, int) get_round_constant(int index) inline {
    if (index == 0) { return (0x0ee9a592ba9a9518, 0, 0, 0); }
    if (index == 1) { return (0x24b0e277fba3c833, 0, 0, 0); }
    if (index == 2) { return (0x0f2d8a3d6a83d9e9, 0, 0, 0); }
    if (index == 3) { return (0x2a9e3523d8158fde, 0, 0, 0); }
    ;; ... (implement for all 256 round constants)
    return (0, 0, 0, 0);  ;; Should never reach here if all constants are defined
}
;; ===========================================================
;; 3. Poseidon2 Permutation
;; ===========================================================

(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int) poseidon2_permutation(
    int s00, int s01, int s02, int s03,  ;; State 0
    int s10, int s11, int s12, int s13,  ;; State 1
    int s20, int s21, int s22, int s23,  ;; State 2
    int s30, int s31, int s32, int s33   ;; State 3
) inline {
    int i = 0;
    while (i < TOTAL_ROUNDS) {
        ;; Add round constants
        (int rc0, int rc1, int rc2, int rc3) = get_round_constant(i * 4);
        (s00, s01, s02, s03) = add_mod_limbs(s00, s01, s02, s03, rc0, rc1, rc2, rc3);
        (rc0, rc1, rc2, rc3) = get_round_constant(i * 4 + 1);
        (s10, s11, s12, s13) = add_mod_limbs(s10, s11, s12, s13, rc0, rc1, rc2, rc3);
        (rc0, rc1, rc2, rc3) = get_round_constant(i * 4 + 2);
        (s20, s21, s22, s23) = add_mod_limbs(s20, s21, s22, s23, rc0, rc1, rc2, rc3);
        (rc0, rc1, rc2, rc3) = get_round_constant(i * 4 + 3);
        (s30, s31, s32, s33) = add_mod_limbs(s30, s31, s32, s33, rc0, rc1, rc2, rc3);

        ;; Apply S-box
        if (i < RF_FULL / 2) | (i >= RF_FULL / 2 + RP_PARTIAL) {
            (s00, s01, s02, s03) = sbox_limbs(s00, s01, s02, s03);
            (s10, s11, s12, s13) = sbox_limbs(s10, s11, s12, s13);
            (s20, s21, s22, s23) = sbox_limbs(s20, s21, s22, s23);
            (s30, s31, s32, s33) = sbox_limbs(s30, s31, s32, s33);
        } else {
            (s00, s01, s02, s03) = sbox_limbs(s00, s01, s02, s03);
        }

        ;; Apply linear layer (MDS matrix multiplication)
        int t00 = 0; int t01 = 0; int t02 = 0; int t03 = 0;
        int t10 = 0; int t11 = 0; int t12 = 0; int t13 = 0;
        int t20 = 0; int t21 = 0; int t22 = 0; int t23 = 0;
        int t30 = 0; int t31 = 0; int t32 = 0; int t33 = 0;

        (t00, t01, t02, t03) = mul_mod_limbs(M00, 0, 0, 0, s00, s01, s02, s03);
        (t10, t11, t12, t13) = mul_mod_limbs(M01, 0, 0, 0, s10, s11, s12, s13);
        (t20, t21, t22, t23) = mul_mod_limbs(M02, 0, 0, 0, s20, s21, s22, s23);
        (t30, t31, t32, t33) = mul_mod_limbs(M03, 0, 0, 0, s30, s31, s32, s33);
        (s00, s01, s02, s03) = add_mod_limbs(t00, t01, t02, t03, t10, t11, t12, t13);
        (s00, s01, s02, s03) = add_mod_limbs(s00, s01, s02, s03, t20, t21, t22, t23);
        (s00, s01, s02, s03) = add_mod_limbs(s00, s01, s02, s03, t30, t31, t32, t33);

        (t00, t01, t02, t03) = mul_mod_limbs(M10, 0, 0, 0, s00, s01, s02, s03);
        (t10, t11, t12, t13) = mul_mod_limbs(M11, 0, 0, 0, s10, s11, s12, s13);
        (t20, t21, t22, t23) = mul_mod_limbs(M12, 0, 0, 0, s20, s21, s22, s23);
        (t30, t31, t32, t33) = mul_mod_limbs(M13, 0, 0, 0, s30, s31, s32, s33);
        (s10, s11, s12, s13) = add_mod_limbs(t00, t01, t02, t03, t10, t11, t12, t13);
        (s10, s11, s12, s13) = add_mod_limbs(s10, s11, s12, s13, t20, t21, t22, t23);
        (s10, s11, s12, s13) = add_mod_limbs(s10, s11, s12, s13, t30, t31, t32, t33);

        (t00, t01, t02, t03) = mul_mod_limbs(M20, 0, 0, 0, s00, s01, s02, s03);
        (t10, t11, t12, t13) = mul_mod_limbs(M31, 0, 0, 0, s10, s11, s12, s13);
        (t20, t21, t22, t23) = mul_mod_limbs(M32, 0, 0, 0, s20, s21, s22, s23);
        (t30, t31, t32, t33) = mul_mod_limbs(M33, 0, 0, 0, s30, s31, s32, s33);
        (s30, s31, s32, s33) = add_mod_limbs(t00, t01, t02, t03, t10, t11, t12, t13);
        (s30, s31, s32, s33) = add_mod_limbs(s30, s31, s32, s33, t20, t21, t22, t23);
        (s30, s31, s32, s33) = add_mod_limbs(s30, s31, s32, s33, t30, t31, t32, t33);

        i += 1;
    }
    return (s00, s01, s02, s03, s10, s11, s12, s13, s20, s21, s22, s23, s30, s31, s32, s33);
}

;; ===========================================================
;; 4. Poseidon2 Hash Function
;; ===========================================================

(int, int, int, int, int, int, int, int) poseidon2_hash(
    int in00, int in01, int in02, int in03,  ;; Input 0
    int in10, int in11, int in12, int in13   ;; Input 1
) {
    ;; Initialize state with inputs and capacity elements set to zero
    (int s00, int s01, int s02, int s03,
     int s10, int s11, int s12, int s13,
     int s20, int s21, int s22, int s23,
     int s30, int s31, int s32, int s33) = poseidon2_permutation(
        in00, in01, in02, in03,
        in10, in11, in12, in13,
        0, 0, 0, 0,  ;; Capacity element
        0, 0, 0, 0   ;; Capacity element
    );
    
    ;; Return the hash (first two state elements)
    return (s00, s01, s02, s03, s10, s11, s12, s13);
}

;; ===========================================================
;; 5. Contract Entry Point
;; ===========================================================

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; Parse the incoming message
    slice cs = in_msg_cell.begin_parse();
    int flags = cs~load_uint(4);
    
    ;; Ignore all bounced messages
    if (flags & 1) {
        return ();
    }

    ;; Extract the operation type from the incoming message
    if (in_msg.slice_empty?()) {
        return ();  ;; Exit if the message is empty
    }
    int op = in_msg~load_uint(32);

    ;; Handle different operations
    if (op == 1) {  ;; Compute Poseidon2 hash
        int in00 = in_msg~load_uint(64);
        int in01 = in_msg~load_uint(64);
        int in02 = in_msg~load_uint(64);
        int in03 = in_msg~load_uint(64);
        int in10 = in_msg~load_uint(64);
        int in11 = in_msg~load_uint(64);
        int in12 = in_msg~load_uint(64);
        int in13 = in_msg~load_uint(64);
        
        (int hash00, int hash01, int hash02, int hash03,
         int hash10, int hash11, int hash12, int hash13) = poseidon2_hash(
            in00, in01, in02, in03, in10, in11, in12, in13
        );
        
        ;; Send the hash result back
        cell msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce
            .store_uint(0, 2) ;; sender address (empty addr)
            .store_uint(0x076ef1ea, 32) ;; op for outgoing message
            .store_uint(hash00, 64)
            .store_uint(hash01, 64)
            .store_uint(hash02, 64)
            .store_uint(hash03, 64)
            .store_uint(hash10, 64)
            .store_uint(hash11, 64)
            .store_uint(hash12, 64)
            .store_uint(hash13, 64)
            .end_cell();
        send_raw_message(msg, 64); ;; mode 64: carry all remaining value of the inbound message
    } else {
        throw(0xffff);  ;; Throw exception for unknown operations
    }
}

;; ===========================================================
;; 6. Get Method for Off-chain Use
;; ===========================================================

(int, int, int, int, int, int, int, int) get_poseidon2_hash(
    int in00, int in01, int in02, int in03,
    int in10, int in11, int in12, int in13
) method_id {
    return poseidon2_hash(in00, in01, in02, in03, in10, in11, in12, in13);
}
</code></pre>
<p></p>
