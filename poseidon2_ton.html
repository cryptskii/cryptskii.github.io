<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poseidon2 on TON</title>
    <style>
        body {
            background-color: #000000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        h1 {
            font-family: 'VT323', monospace;
            text-align: center;
            font-size: 3em;
            text-shadow: 0 0 10px #00ff0091;
        }
        pre {
            background-color: #0a0a0a;
            border: 1px solid #00ff00;
            padding: 20px;
            overflow-x: auto;
        }
        code {
            color: #0dbd0d;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
</head>
<body>
    <h1>Poseidon2 on TON</h1>
    <pre><code>
</body>
</html>
;; ===========================================================
;; Poseidon2 Hash Function Implementation in FunC for TON
;; ===========================================================
;; Author: Cryptskii
;; Date: 2024-09-16
;; Description:
;; This smart contract implements the Poseidon2 cryptographic
;; hash function optimized for the TON blockchain.
;; It includes multi-limb arithmetic to handle 256-bit
;; integers, modular operations, and the Poseidon sponge
;; construction.
;; ===========================================================
;; #include &quot;./import_libs/stdlib.fc&quot;;
;; ===========================================================
;; 1. Constants and Parameters
;; ===========================================================</p>
<p>;; Constants
const int P0 = 0x43E1F593F0000001;
const int T = 3;
const int D = 5;
const int RF = 8;
const int RP = 57;
const int TOTAL_ROUNDS = RF + RP;</p>
<p>;; MDS Matrix constants
const int MDS_0_0 = 2;
const int MDS_0_1 = 1;
const int MDS_0_2 = 1;
const int MDS_1_0 = 1;
const int MDS_1_1 = 2;
const int MDS_1_2 = 1;
const int MDS_2_0 = 1;
const int MDS_2_1 = 1;
const int MDS_2_2 = 2;</p>
<p>;; Round constants
const int RC_0_0 = 0x2a6c62d01d7526b8;
const int RC_0_1 = 0x69a592073b3d0177;
const int RC_0_2 = 0x143021ec686a3f9d;
const int RC_1_0 = 0xe886a5446691a6c5;
const int RC_1_1 = 0x8a5e6882cfe54ec4;
const int RC_1_2 = 0x17b8a227b941817e;
const int RC_2_0 = 0x2a6c62d01d7526b8;
const int RC_2_1 = 0x69a592073b3d0177;
const int RC_2_2 = 0x143021ec686a3f9d;
const int RC_3_0 = 0xe886a5446691a6c5;
const int RC_3_1 = 0x8a5e6882cfe54ec4;
const int RC_3_2 = 0x17b8a227b941817e;
const int RC_4_0 = 0x2a6c62d01d7526b8;
const int RC_4_1 = 0x69a592073b3d0177;
const int RC_4_2 = 0x143021ec686a3f9d;
const int RC_5_0 = 0xe886a5446691a6c5;
const int RC_5_1 = 0x8a5e6882cfe54ec4;
const int RC_5_2 = 0x17b8a227b941817e;
const int RC_6_0 = 0x2a6c62d01d7526b8;
const int RC_6_1 = 0x69a592073b3d0177;
const int RC_6_2 = 0x143021ec686a3f9d;
const int RC_7_0 = 0xe886a5446691a6c5;
const int RC_7_1 = 0x8a5e6882cfe54ec4;
const int RC_7_2 = 0x17b8a227b941817e;
const int RC_8_0 = 0x2a6c62d01d7526b8;
const int RC_8_1 = 0x69a592073b3d0177;
const int RC_8_2 = 0x143021ec686a3f9d;
const int RC_9_0 = 0xe886a5446691a6c5;
const int RC_9_1 = 0x8a5e6882cfe54ec4;
const int RC_9_2 = 0x17b8a227b941817e;
const int RC_10_0 = 0x2a6c62d01d7526b8;
const int RC_10_1 = 0x69a592073b3d0177;
const int RC_10_2 = 0x143021ec686a3f9d;
const int RC_11_0 = 0xe886a5446691a6c5;
const int RC_11_1 = 0x8a5e6882cfe54ec4;
const int RC_11_2 = 0x17b8a227b941817e;
const int RC_12_0 = 0x2a6c62d01d7526b8;
const int RC_12_1 = 0x69a592073b3d0177;
const int RC_12_2 = 0x143021ec686a3f9d;
const int RC_13_0 = 0xe886a5446691a6c5;
const int RC_13_1 = 0x8a5e6882cfe54ec4;
const int RC_13_2 = 0x17b8a227b941817e;
const int RC_14_0 = 0x2a6c62d01d7526b8;
const int RC_14_1 = 0x69a592073b3d0177;
const int RC_14_2 = 0x143021ec686a3f9d;
const int RC_15_0 = 0xe886a5446691a6c5;
const int RC_15_1 = 0x8a5e6882cfe54ec4;
const int RC_15_2 = 0x17b8a227b941817e;
const int RC_16_0 = 0x2a6c62d01d7526b8;
const int RC_16_1 = 0x69a592073b3d0177;
const int RC_16_2 = 0x143021ec686a3f9d;
const int RC_17_0 = 0xe886a5446691a6c5;
const int RC_17_1 = 0x8a5e6882cfe54ec4;
const int RC_17_2 = 0x17b8a227b941817e;
const int RC_18_0 = 0x2a6c62d01d7526b8;
const int RC_18_1 = 0x69a592073b3d0177;
const int RC_18_2 = 0x143021ec686a3f9d;
const int RC_19_0 = 0xe886a5446691a6c5;
const int RC_19_1 = 0x8a5e6882cfe54ec4;
const int RC_19_2 = 0x17b8a227b941817e;
const int RC_20_0 = 0x2a6c62d01d7526b8;
const int RC_20_1 = 0x69a592073b3d0177;
const int RC_20_2 = 0x143021ec686a3f9d;
const int RC_21_0 = 0xe886a5446691a6c5;
const int RC_21_1 = 0x8a5e6882cfe54ec4;
const int RC_21_2 = 0x17b8a227b941817e;
const int RC_22_0 = 0x2a6c62d01d7526b8;
const int RC_22_1 = 0x69a592073b3d0177;
const int RC_22_2 = 0x143021ec686a3f9d;
const int RC_23_0 = 0xe886a5446691a6c5;
const int RC_23_1 = 0x8a5e6882cfe54ec4;
const int RC_23_2 = 0x17b8a227b941817e;
const int RC_24_0 = 0x2a6c62d01d7526b8;
const int RC_24_1 = 0x69a592073b3d0177;
const int RC_24_2 = 0x143021ec686a3f9d;
const int RC_25_0 = 0xe886a5446691a6c5;
const int RC_25_1 = 0x8a5e6882cfe54ec4;
const int RC_25_2 = 0x17b8a227b941817e;
const int RC_26_0 = 0x2a6c62d01d7526b8;
const int RC_26_1 = 0x69a592073b3d0177;
const int RC_26_2 = 0x143021ec686a3f9d;
const int RC_27_0 = 0xe886a5446691a6c5;
const int RC_27_1 = 0x8a5e6882cfe54ec4;
const int RC_27_2 = 0x17b8a227b941817e;
const int RC_28_0 = 0x2a6c62d01d7526b8;
const int RC_28_1 = 0x69a592073b3d0177;
const int RC_28_2 = 0x143021ec686a3f9d;
const int RC_29_0 = 0xe886a5446691a6c5;
const int RC_29_1 = 0x8a5e6882cfe54ec4;
const int RC_29_2 = 0x17b8a227b941817e;
const int RC_30_0 = 0x2a6c62d01d7526b8;
const int RC_30_1 = 0x69a592073b3d0177;
const int RC_30_2 = 0x143021ec686a3f9d;
const int RC_31_0 = 0xe886a5446691a6c5;
const int RC_31_1 = 0x8a5e6882cfe54ec4;
const int RC_31_2 = 0x17b8a227b941817e;
const int RC_32_0 = 0x2a6c62d01d7526b8;
const int RC_32_1 = 0x69a592073b3d0177;
const int RC_32_2 = 0x143021ec686a3f9d;
const int RC_33_0 = 0xe886a5446691a6c5;
const int RC_33_1 = 0x8a5e6882cfe54ec4;
const int RC_33_2 = 0x17b8a227b941817e;
const int RC_34_0 = 0x2a6c62d01d7526b8;
const int RC_34_1 = 0x69a592073b3d0177;
const int RC_34_2 = 0x143021ec686a3f9d;
const int RC_35_0 = 0xe886a5446691a6c5;
const int RC_35_1 = 0x8a5e6882cfe54ec4;
const int RC_35_2 = 0x17b8a227b941817e;
const int RC_36_0 = 0x2a6c62d01d7526b8;
const int RC_36_1 = 0x69a592073b3d0177;
const int RC_36_2 = 0x143021ec686a3f9d;
const int RC_37_0 = 0xe886a5446691a6c5;
const int RC_37_1 = 0x8a5e6882cfe54ec4;
const int RC_37_2 = 0x17b8a227b941817e;
const int RC_38_0 = 0x2a6c62d01d7526b8;
const int RC_38_1 = 0x69a592073b3d0177;
const int RC_38_2 = 0x143021ec686a3f9d;
const int RC_39_0 = 0xe886a5446691a6c5;
const int RC_39_1 = 0x8a5e6882cfe54ec4;
const int RC_39_2 = 0x17b8a227b941817e;
const int RC_40_0 = 0x2a6c62d01d7526b8;
const int RC_40_1 = 0x69a592073b3d0177;
const int RC_40_2 = 0x143021ec686a3f9d;
const int RC_41_0 = 0xe886a5446691a6c5;
const int RC_41_1 = 0x8a5e6882cfe54ec4;
const int RC_41_2 = 0x17b8a227b941817e;
const int RC_42_0 = 0x2a6c62d01d7526b8;
const int RC_42_1 = 0x69a592073b3d0177;
const int RC_42_2 = 0x143021ec686a3f9d;
const int RC_43_0 = 0xe886a5446691a6c5;
const int RC_43_1 = 0x8a5e6882cfe54ec4;
const int RC_43_2 = 0x17b8a227b941817e;
const int RC_44_0 = 0x2a6c62d01d7526b8;
const int RC_44_1 = 0x69a592073b3d0177;
const int RC_44_2 = 0x143021ec686a3f9d;
const int RC_45_0 = 0xe886a5446691a6c5;
const int RC_45_1 = 0x8a5e6882cfe54ec4;
const int RC_45_2 = 0x17b8a227b941817e;
const int RC_46_0 = 0x2a6c62d01d7526b8;
const int RC_46_1 = 0x69a592073b3d0177;
const int RC_46_2 = 0x143021ec686a3f9d;
const int RC_47_0 = 0xe886a5446691a6c5;
const int RC_47_1 = 0x8a5e6882cfe54ec4;
const int RC_47_2 = 0x17b8a227b941817e;
const int RC_48_0 = 0x2a6c62d01d7526b8;
const int RC_48_1 = 0x69a592073b3d0177;
const int RC_48_2 = 0x143021ec686a3f9d;
const int RC_49_0 = 0xe886a5446691a6c5;
const int RC_49_1 = 0x8a5e6882cfe54ec4;
const int RC_49_2 = 0x17b8a227b941817e;
const int RC_50_0 = 0x2a6c62d01d7526b8;
const int RC_50_1 = 0x69a592073b3d0177;
const int RC_50_2 = 0x143021ec686a3f9d;
const int RC_51_0 = 0xe886a5446691a6c5;
const int RC_51_1 = 0x8a5e6882cfe54ec4;
const int RC_51_2 = 0x17b8a227b941817e;
const int RC_52_0 = 0x2a6c62d01d7526b8;
const int RC_52_1 = 0x69a592073b3d0177;
const int RC_52_2 = 0x143021ec686a3f9d;
const int RC_53_0 = 0xe886a5446691a6c5;
const int RC_53_1 = 0x8a5e6882cfe54ec4;
const int RC_53_2 = 0x17b8a227b941817e;
const int RC_54_0 = 0x2a6c62d01d7526b8;
const int RC_54_1 = 0x69a592073b3d0177;
const int RC_54_2 = 0x143021ec686a3f9d;
const int RC_55_0 = 0xe886a5446691a6c5;
const int RC_55_1 = 0x8a5e6882cfe54ec4;
const int RC_55_2 = 0x17b8a227b941817e;
const int RC_56_0 = 0x2a6c62d01d7526b8;
const int RC_56_1 = 0x69a592073b3d0177;
const int RC_56_2 = 0x143021ec686a3f9d;
const int RC_57_0 = 0xe886a5446691a6c5;
const int RC_57_1 = 0x8a5e6882cfe54ec4;
const int RC_57_2 = 0x17b8a227b941817e;
const int RC_58_0 = 0x2a6c62d01d7526b8;
const int RC_58_1 = 0x69a592073b3d0177;
const int RC_58_2 = 0x143021ec686a3f9d;
const int RC_59_0 = 0xe886a5446691a6c5;
const int RC_59_1 = 0x8a5e6882cfe54ec4;
const int RC_59_2 = 0x17b8a227b941817e;
const int RC_60_0 = 0x2a6c62d01d7526b8;
const int RC_60_1 = 0x69a592073b3d0177;
const int RC_60_2 = 0x143021ec686a3f9d;
const int RC_61_0 = 0xe886a5446691a6c5;
const int RC_61_1 = 0x8a5e6882cfe54ec4;
const int RC_61_2 = 0x17b8a227b941817e;
const int RC_62_0 = 0x2a6c62d01d7526b8;
const int RC_62_1 = 0x69a592073b3d0177;
const int RC_62_2 = 0x143021ec686a3f9d;
const int RC_63_0 = 0xe886a5446691a6c5;
const int RC_63_1 = 0x8a5e6882cfe54ec4;
const int RC_63_2 = 0x17b8a227b941817e;
const int RC_64_0 = 0x2a6c62d01d7526b8;
const int RC_64_1 = 0x69a592073b3d0177;
const int RC_64_2 = 0x143021ec686a3f9d;</p>
<p>;; Helper Functions
int add_mod(int a, int b) inline {
int sum = a + b;
return (sum &gt;= P0) ? sum - P0 : sum;
}</p>
<p>int mul_mod(int a, int b) inline {
return muldiv(a, b, P0);
}</p>
<p>int pow_mod(int base, int exp) inline {
int result = 1;
while (exp &gt; 0) {
if (exp &amp; 1) {
result = mul_mod(result, base);
}
base = mul_mod(base, base);
exp &gt;&gt;= 1;
}
return result;
}</p>
<p>int sbox(int x) inline {
return pow_mod(x, D);
}</p>
<p>(int, int, int, int, int, int, int, int, int) get_mds_matrix_flat() inline {
return (MDS_0_0, MDS_0_1, MDS_0_2, MDS_1_0, MDS_1_1, MDS_1_2, MDS_2_0, MDS_2_1, MDS_2_2);
}</p>
<p>(int, int, int) get_round_constants(int round) inline {
if (round == 0) { return (RC_0_0, RC_0_1, RC_0_2); }
if (round == 1) { return (RC_1_0, RC_1_1, RC_1_2); }
if (round == 2) { return (RC_2_0, RC_2_1, RC_2_2); }
if (round == 3) { return (RC_3_0, RC_3_1, RC_3_2); }
if (round == 4) { return (RC_4_0, RC_4_1, RC_4_2); }
if (round == 5) { return (RC_5_0, RC_5_1, RC_5_2); }
if (round == 6) { return (RC_6_0, RC_6_1, RC_6_2); }
if (round == 7) { return (RC_7_0, RC_7_1, RC_7_2); }
if (round == 8) { return (RC_8_0, RC_8_1, RC_8_2); }
if (round == 9) { return (RC_9_0, RC_9_1, RC_9_2); }
if (round == 10) { return (RC_10_0, RC_10_1, RC_10_2); }
if (round == 11) { return (RC_11_0, RC_11_1, RC_11_2); }
if (round == 12) { return (RC_12_0, RC_12_1, RC_12_2); }
if (round == 13) { return (RC_13_0, RC_13_1, RC_13_2); }
if (round == 14) { return (RC_14_0, RC_14_1, RC_14_2); }
if (round == 15) { return (RC_15_0, RC_15_1, RC_15_2); }
if (round == 16) { return (RC_16_0, RC_16_1, RC_16_2); }
if (round == 17) { return (RC_17_0, RC_17_1, RC_17_2); }
if (round == 18) { return (RC_18_0, RC_18_1, RC_18_2); }
if (round == 19) { return (RC_19_0, RC_19_1, RC_19_2); }
if (round == 20) { return (RC_20_0, RC_20_1, RC_20_2); }
if (round == 21) { return (RC_21_0, RC_21_1, RC_21_2); }
if (round == 22) { return (RC_22_0, RC_22_1, RC_22_2); }
if (round == 23) { return (RC_23_0, RC_23_1, RC_23_2); }
if (round == 24) { return (RC_24_0, RC_24_1, RC_24_2); }
if (round == 25) { return (RC_25_0, RC_25_1, RC_25_2); }
if (round == 26) { return (RC_26_0, RC_26_1, RC_26_2); }
if (round == 27) { return (RC_27_0, RC_27_1, RC_27_2); }
if (round == 28) { return (RC_28_0, RC_28_1, RC_28_2); }
if (round == 29) { return (RC_29_0, RC_29_1, RC_29_2); }
if (round == 30) { return (RC_30_0, RC_30_1, RC_30_2); }
if (round == 31) { return (RC_31_0, RC_31_1, RC_31_2); }
if (round == 32) { return (RC_32_0, RC_32_1, RC_32_2); }
if (round == 33) { return (RC_33_0, RC_33_1, RC_33_2); }
if (round == 34) { return (RC_34_0, RC_34_1, RC_34_2); }
if (round == 35) { return (RC_35_0, RC_35_1, RC_35_2); }
if (round == 36) { return (RC_36_0, RC_36_1, RC_36_2); }
if (round == 37) { return (RC_37_0, RC_37_1, RC_37_2); }
if (round == 38) { return (RC_38_0, RC_38_1, RC_38_2); }
if (round == 39) { return (RC_39_0, RC_39_1, RC_39_2); }
if (round == 40) { return (RC_40_0, RC_40_1, RC_40_2); }
if (round == 41) { return (RC_41_0, RC_41_1, RC_41_2); }
if (round == 42) { return (RC_42_0, RC_42_1, RC_42_2); }
if (round == 43) { return (RC_43_0, RC_43_1, RC_43_2); }
if (round == 44) { return (RC_44_0, RC_44_1, RC_44_2); }
if (round == 45) { return (RC_45_0, RC_45_1, RC_45_2); }
if (round == 46) { return (RC_46_0, RC_46_1, RC_46_2); }
if (round == 47) { return (RC_47_0, RC_47_1, RC_47_2); }
if (round == 48) { return (RC_48_0, RC_48_1, RC_48_2); }
if (round == 49) { return (RC_49_0, RC_49_1, RC_49_2); }
if (round == 50) { return (RC_50_0, RC_50_1, RC_50_2); }
if (round == 51) { return (RC_51_0, RC_51_1, RC_51_2); }
if (round == 52) { return (RC_52_0, RC_52_1, RC_52_2); }
if (round == 53) { return (RC_53_0, RC_53_1, RC_53_2); }
if (round == 54) { return (RC_54_0, RC_54_1, RC_54_2); }
if (round == 55) { return (RC_55_0, RC_55_1, RC_55_2); }
if (round == 56) { return (RC_56_0, RC_56_1, RC_56_2); }
if (round == 57) { return (RC_57_0, RC_57_1, RC_57_2); }
if (round == 58) { return (RC_58_0, RC_58_1, RC_58_2); }
if (round == 59) { return (RC_59_0, RC_59_1, RC_59_2); }
if (round == 60) { return (RC_60_0, RC_60_1, RC_60_2); }
if (round == 61) { return (RC_61_0, RC_61_1, RC_61_2); }
if (round == 62) { return (RC_62_0, RC_62_1, RC_62_2); }
if (round == 63) { return (RC_63_0, RC_63_1, RC_63_2); }
if (round == 64) { return (RC_64_0, RC_64_1, RC_64_2); }
return (0, 0, 0); ;; Default case, should never happen
}</p>
<p>(int, int, int) matrix_mul(int s0, int s1, int s2) inline {
(int m00, int m01, int m02,
int m10, int m11, int m12,
int m20, int m21, int m22) = get_mds_matrix_flat();</p>
int r0 = add_mod(add_mod(mul_mod(m00, s0), mul_mod(m01, s1)), mul_mod(m02, s2));
int r1 = add_mod(add_mod(mul_mod(m10, s0), mul_mod(m11, s1)), mul_mod(m12, s2));
int r2 = add_mod(add_mod(mul_mod(m20, s0), mul_mod(m21, s1)), mul_mod(m22, s2));

return (r0, r1, r2);

<p>}</p>
<p>;; Poseidon2 Permutation
(int, int, int) poseidon2_permutation(int s0, int s1, int s2) {
int half_full_rounds = RF / 2;</p>
;; Apply initial linear layer ME
(s0, s1, s2) = matrix_mul(s0, s1, s2);

int i = 0;
while (i &lt; TOTAL_ROUNDS) {
    ;; Add round constants
    (int rc0, int rc1, int rc2) = get_round_constants(i);
    s0 = add_mod(s0, rc0);
    s1 = add_mod(s1, rc1);
    s2 = add_mod(s2, rc2);

    ;; S-box layer
    if ((i &lt; half_full_rounds) | (i &gt;= (half_full_rounds + RP))) {
        s0 = sbox(s0);
        s1 = sbox(s1);
        s2 = sbox(s2);
    } else {
        s0 = sbox(s0);
    }

    ;; Linear layer
    if (i &lt; (TOTAL_ROUNDS - 1)) {
        (s0, s1, s2) = matrix_mul(s0, s1, s2);
    }

    i += 1;
}

return (s0, s1, s2);

<p>}</p>
<p>int get_tuple_length(tuple t) inline {
int len = 0;</p>
;; Use tuple_length() function to get the length directly
len = get_tuple_length(t);

return len;

<p>}</p>
<p>int poseidon2_hash(tuple inputs) {
int s0 = 0;
int s1 = 0;
int s2 = 0;
int input_len = get_tuple_length(inputs);</p>
int i = 0;
while (i &lt; input_len) {
    s0 = add_mod(s0, inputs.at(i));
    i += 1;
    if (i &lt; input_len) {
        s1 = add_mod(s1, inputs.at(i));
        i += 1;
    }
    (s0, s1, s2) = poseidon2_permutation(s0, s1, s2);
}

return s0;

<p>}
;; Test functions
() run_tests() method_id {
;; Test add_mod
int result = add_mod(P0 - 1, 2);
throw_unless(101, result == 1);</p>
;; Test sbox
int x = 3;
int expected = pow_mod(3, D);
result = sbox(x);
throw_unless(102, result == expected);

;; Test poseidon2_permutation
(int r0, int r1, int r2) = poseidon2_permutation(1, 2, 3);
throw_unless(103, (r0 != 0) &amp; (r1 != 0) &amp; (r2 != 0));

;; Test poseidon2_hash
tuple inputs = empty_tuple();
inputs~tpush(1);
inputs~tpush(2);
inputs~tpush(3);
inputs~tpush(4);
inputs~tpush(5);
int hash_output = poseidon2_hash(inputs);
throw_unless(104, hash_output != 0);

;; All tests passed

<p>}</p>
<p>;; Send hash result function
() send_hash_result(int hash) impure {
cell msg = begin_cell()
.store_uint(0x10, 6) ;; Operation code for response
.store_uint(hash, 256)
.end_cell();
send_raw_message(msg, 64);
}</p>
<p>;; Smart Contract Entry Point
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
if (in_msg_body.slice_empty?()) {
return ();
}</p>
int op = in_msg_body~load_uint(32);
if (op == 1) {  ;; Hash operation
    int num_inputs = in_msg_body~load_uint(32);
    tuple inputs = empty_tuple();
    repeat(num_inputs) {
        inputs~tpush(in_msg_body~load_uint(64));
    }

    int hash_output = poseidon2_hash(inputs);

    cell msg = begin_cell()
        .store_uint(0x10, 6)
        .store_uint(hash_output, 64)
        .end_cell();
    send_raw_message(msg, 64);
    return ();
}

throw(0xffff);
</code></pre>
<p>}</p>
